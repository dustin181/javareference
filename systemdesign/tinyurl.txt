1) Functional requirements:

	a) BigUrl -> Create -> ShortUrl
	b) ShortUrl -> Get -> BigUrl
	c) Length of Url = 6 characters
	d) characters should be random
	e) Need an account to return a URL
	f) Monitoring/Analytics (Four Golden Signals)

2) Nonfunctional requirements:
	a) Fault Tolerant
	b) Highly Available
	c) Minimal Latency
	d) Scalable
	e) Consistency: Strong
	f) Durablility
	g) Minmize Cost

3) API

Login(usertoken)
Logoff(usertoken)
createShortUrl(userToken, bigUrl) --> return shortURL
getBigUrl(shortUrl) --> return bigUrl

4) Datastore

a) Multiple Partitions
b) Two or more replicas storing partitions
c) Scales up as data increases (more partitions)
d) Single partition stored in multiple replicas for durability
e) Could have a job that looks for expired links every month as a low priority and deletes them.  Should return the short url to the pool.

5) Cache
a) reads will greatly outnumber writes
b) local in memory cache and global distributed cache
c) possible sentinel value in global cache to stop repeated cache searches for missing values

6) Encoding
a) base64 (a-z, A-Z, 0-9, -, _) -> 64^6 = 70 billion urls
b) md5 wont work because 128-bit or 21 chars
c) key generation service is possible but it drives up costs
d) read from counter in datastore via transactions (intervals of 100 or 1000) and the app will know it can use 1-100 or 101-200, etc.  Application increments by 100 or 1000 when it reads a value.

7) Schema:

URL_Mapping:
PK ShortUrl: varchar(16)
BigUrl: varchar(1024)
creationTime: datetime
expirationTime: datetime
SK userId: integer

Users:
userid: integer
name: varchar(100)
email: varchar(100)
creationTime: datetime
lastloginTime: datetime


	 